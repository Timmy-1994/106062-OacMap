/*  Global class for simulating the movement of particle through a 1km wind grid

    credit: All the credit for this work goes to: https://github.com/cambecc for creating the repo:
    https://github.com/cambecc/earth. The majority of this code is directly take nfrom there, since its awesome.

    This class takes a canvas element and an array of data (1km GFS from http://www.emc.ncep.noaa.gov/index.php?branch=GFS)
    and then uses a mercator (forward/reverse) projection to correctly map wind vectors in "map space".

    The "start" method takes the bounds of the map at its current extent and starts the whole gridding,
    interpolation and animation process.
 */

/**
 * @returns {Boolean} true if the specified value is not null and not undefined.
 */
const isValue = x => x !== null && x !== undefined;

/**
 * @returns {Number} returns remainder of floored division, i.e., floor(a / n). Useful for consistent modulo
 * of negative numbers. See http://en.wikipedia.org/wiki/Modulo_operation.
*/
const floorMod = (a, n) => a - n * Math.floor(a / n);

const deg2rad = deg => deg / 180 * Math.PI

export class Windy {

    /**velocity at which particle intensity is minimum (m/s) */
    MIN_VELOCITY_INTENSITY:number = 0
    /**velocity at which particle intensity is maximum (m/s) */
    MAX_VELOCITY_INTENSITY:number = 10
    /**scale for wind velocity (completely arbitrary--this value looks nice) */
    VELOCITY_SCALE:number = (0.005 * (Math.pow(window.devicePixelRatio, 1 / 3)) || 1)
    /** max number of frames a particle is drawn before regeneration */
    MAX_PARTICLE_AGE:number = 90
    /** line width of a drawn particle */
    PARTICLE_LINE_WIDTH:number = 1
    /** particle count scalar (completely arbitrary--this values looks nice) */
    PARTICLE_MULTIPLIER:number = 1 / 300
    /** multiply particle count for mobiles by this amount */
    PARTICLE_REDUCTION:number = 1.6
    FRAME_RATE:number = 60
    /** desired frames per second */
    FRAME_TIME:number = 1000 / this.FRAME_RATE 
    OPACITY:number = 0.97
    reverseX:boolean = false
    reverseY:boolean = false
    defaulColorScale:Array<string> = ["rgb(36,104, 180)", "rgb(60,157, 194)", "rgb(128,205,193 )", "rgb(151,218,168 )", "rgb(198,231,181)", "rgb(238,247,217)", "rgb(255,238,159)", "rgb(252,217,125)", "rgb(255,182,100)", "rgb(252,150,75)", "rgb(250,112,52)", "rgb(245,64,32)", "rgb(237,45,28)", "rgb(220,24,32)", "rgb(180,0,35)"]
    colorScale:Array<string> = this.defaulColorScale
    /**singleton for no wind in the form: [u, v, magnitude] */
    NULL_WIND_VECTOR:Array<any> = [NaN, NaN, null]

    Builder:Builder

    gridData:any

    constructor({
        minVelocity,
        maxVelocity,
        velocityScale,
        particleAge,
        lineWidth,
        particleMultiplier,
        frameRate,
        colorScale,
        data
    }){
        this.MIN_VELOCITY_INTENSITY = minVelocity
        this.MAX_VELOCITY_INTENSITY = maxVelocity
        this.VELOCITY_SCALE = (velocityScale || 0.005) * (Math.pow(window.devicePixelRatio, 1 / 3))
        this.MAX_PARTICLE_AGE = particleAge
        this.PARTICLE_LINE_WIDTH = lineWidth
        this.PARTICLE_MULTIPLIER = particleMultiplier
        this.PARTICLE_REDUCTION = Math.pow(window.devicePixelRatio, 1 / 3)
        this.FRAME_RATE = frameRate
        this.FRAME_TIME = 1000 / frameRate
        this.colorScale = colorScale
        this.gridData = data
    }

    setData(data:any){
        this.gridData = data
    }

    setOptions({
        minVelocity,
        maxVelocity,
        velocityScale,
        particleAge,
        lineWidth,
        particleMultiplier,
        opacity,
        frameRate
    }){
        this.MIN_VELOCITY_INTENSITY = minVelocity
        this.MAX_VELOCITY_INTENSITY = maxVelocity
        this.VELOCITY_SCALE = (velocityScale || 0.005) * (Math.pow(window.devicePixelRatio, 1 / 3) || 1);
        this.MAX_PARTICLE_AGE = particleAge
        this.PARTICLE_LINE_WIDTH = lineWidth
        this.PARTICLE_MULTIPLIER = particleMultiplier
        this.OPACITY = opacity
        this.FRAME_RATE = frameRate
        this.FRAME_TIME = 1000 / this.FRAME_RATE
    }

    start(bounds, width, height, extent){
        var mapBounds = {
            south: deg2rad(extent[0][1]),
            north: deg2rad(extent[1][1]),
            east: deg2rad(extent[1][0]),
            west: deg2rad(extent[0][0]),
            width: width,
            height: height
        };
        this.stop(); // build grid
        const BuilderIns = new Builder(this.gridData)
    }

    /** TODO: 建立 animate 類、屬性 */
    stop(){
        // if (this.field) this.field.release();
        // if (this.animationLoop) cancelAnimationFrame(animationLoop);
    }


    createField(){}

    /** 雙線性插值向量 */
    
}

class Builder {

    // 必要
    header:any
    data:any

    // ?
    grid:any

    date:Date
    /** the grid's origin (e.g., 0.0E, 90.0N) */
    λ0:number
    φ0:number
    /** distance between grid points (e.g., 2.5 deg lon, 2.5 deg lat) */
    Δλ:number
    Δφ:number
    /** number of grid points W-E and N-S (e.g., 144 x 73) */
    ni:number
    nj:number

    constructor(gridData){
        
        let supported = true

        if(gridData.length < 2)  supported = false
        if(!supported ){
            console.error("Data must have at least two components (u,v)")
            return
        } 

        this.header = gridData.header 
        this.data = gridData.data
        this.λ0 = this.header.lo1
        this.φ0 = this.header.la1
        this.Δλ = this.header.dx
        this.Δφ = this.header.dy
        this.ni = this.header.nx
        this.nj = this.header.ny

        if (this.header.hasOwnProperty("gridDefinitionTemplate") && this.header.gridDefinitionTemplate != 0) supported = false;
        if(!supported ) console.error("Only data with Latitude_Longitude coordinates is supported")

        supported = true; // reset for futher checks

        if (this.header.hasOwnProperty("scanMode")) {
            var scanModeMask = this.header.scanMode.toString(2);
            scanModeMask = ('0' + scanModeMask).slice(-8);
            var scanModeMaskArray = scanModeMask.split('').map(Number).map(Boolean);
            if (scanModeMaskArray[0]) this.Δλ = -this.Δλ;
            if (scanModeMaskArray[1]) this.Δφ = -this.Δφ;
            if (scanModeMaskArray[2]) supported = false;
            if (scanModeMaskArray[3]) supported = false;
            if (scanModeMaskArray[4]) supported = false;
            if (scanModeMaskArray[5]) supported = false;
            if (scanModeMaskArray[6]) supported = false;
            if (scanModeMaskArray[7]) supported = false;
            if (!supported) console.log("Windy Error: Data with scanMode: " + this.header.scanMode + " is not supported.");
        }

        this.date = new Date(this.header.refTime)
        /** Scan modes 0, 64 allowed. */
        this.date.setHours(this.date.getHours() + this.header.forecastTime); // 

    }

    /** @see http://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_table3-4.shtml */
    async buildGrid():Promise<any>{
        this.grid = [];
        var p = 0;
        var isContinuous = Math.floor(this.ni * this.Δλ) >= 360;

        for (var j = 0; j < this.nj; j++) {
            var row = [];

            for (var i = 0; i < this.ni; i++, p++) {
                //        row[i] = builder.data(p);
                if (1) {
                    row.unshift(builder.data(p));
                } else {
                    row.push(builder.data(p));
                }
            }

            if (isContinuous) {
                // For wrapped grids, duplicate first column as last column to simplify interpolation logic
                //        row.push(row[0]);
                if (1) {
                    row.unshift(row[row.length - 1]);
                } else {
                    row.push(row[0]);
                }
            }
            //      grid[j] = row;
            if (1) {
                this.grid.unshift(row);
            } else {
                this.grid.push(row);
            }
        }
    }

    private bilinearInterpolateVector(x:number, y:number, g00:number, g10:number, g01:number, g11:number):[number,number,number]{
        var rx = 1 - x;
        var ry = 1 - y;
        var a = rx * ry,
            b = x * ry,
            c = rx * y,
            d = x * y;
        var u = g00[0] * a + g10[0] * b + g01[0] * c + g11[0] * d;
        var v = g00[1] * a + g10[1] * b + g01[1] * c + g11[1] * d;
        return [u, v, Math.sqrt(u * u + v * v)];
    }

    private createWindBuilder(uComp, vComp){
        var uData = uComp.data,
        vData = vComp.data;
        return {
            header: uComp.header,
            //recipe: recipeFor("wind-" + uComp.header.surface1Value),
            data: function data(i) {
                return [uData[i], vData[i]];
            },
            interpolate: this.bilinearInterpolateVector
        };
    }
    
    private createBuilder(data){
        var uComp = null,
        vComp = null,
        scalar = null;
        data.forEach(function(record) {
            switch (record.header.parameterCategory + "," + record.header.parameterNumber) {
                case "1,2":
                case "2,2":
                    uComp = record;
                    break;

                case "1,3":
                case "2,3":
                    vComp = record;
                    break;

                default:
                    scalar = record;
            }
        });
        return this.createWindBuilder(uComp, vComp);
    }

    /**
     * Get interpolated grid value from Lon/Lat position
     * @param λ {Float} Longitude
     * @param φ {Float} Latitude
     * @returns {Object}
     */
    interpolate(λ:number, φ:number){
        if (!this.grid) return null;
        var i = floorMod(λ - this.λ0, 360) / this.Δλ; // calculate longitude index in wrapped range [0, 360)

        var j = (this.φ0 - φ) / this.Δφ; // calculate latitude index in direction +90 to -90

        var fi = Math.floor(i),
            ci = fi + 1;
        var fj = Math.floor(j),
            cj = fj + 1;
        var row;

        if (row = this.grid[fj]) {
            var g00 = row[fi];
            var g10 = row[ci];

            if (isValue(g00) && isValue(g10) && (row = this.grid[cj])) {
                var g01 = row[fi];
                var g11 = row[ci];

                if (isValue(g01) && isValue(g11)) {
                    // All four points found, so interpolate the value.
                    return this.Builder.interpolate(i - fi, j - fj, g00, g10, g01, g11);
                }
            }
        }

        return null;
    }
}